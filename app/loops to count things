
// functions =====================================================

// sorts an array of objects by key.
function keysrt(key,desc) {
  return function(a,b){
   return desc ? ~~(a[key] < b[key]) : ~~(a[key] > b[key]);
  }
}

function flowcatch(data, match){
	// TODO - add FlowKey and rethink how this pushes into the array
	var flowcatch = [];
        for (var a = 0; a < data.length; a++){
        	for (var b = 0; b < data[a].flows.length; b++){
        		if (data[a].flows[b].flowKey == match){
        			flowcatch.push(data[a].flows[b]);
        		}
        	}
        }
    return flowcatch;
}


function stepcatch(flow_array){

// assemble the steps into their stacks
	var stepcollector = [];
	var stepcheck = [];

	for ( var a = 0; a < flow_array.length; a++){
		var flow = flow_array[a]

		for(var b = 0; b < flow.steps.length; b++){

			var step = flow.steps[b];
	        var name = step.title;
	        var key = step.key;
	        
	        if(flow.user_id){ // if there's a user set on the record, include it.
    	    	if (!(stepcheck.indexOf(key) != -1)){
    	    		// this correctly pushes the first step of the first flow with a user.
    	            var pusher = {'user' : flow.user_id, 'messages' : step.messages }
    
    	            stepcheck.push(key);
    	            stepcollector.push({key: key, name : name, session_by_user : [], pass_fail : false, summary: '' });
    	            stepcollector[b].session_by_user.push(pusher);
    
    	        } else if (stepcheck.indexOf(key) != -1){
    
    	        	for ( var c = 0; c < stepcollector.length; c++){
    	                if (key == stepcollector[c].key){
    	                    var pusher = {'user' : flow.user_id, 'messages' : step.messages }
    	                    stepcollector[c].session_by_user.push(pusher);
    	                    
    	                }
    	            }
    	    	}
    	    }
		}
	}

// here we begin collecting tags from the step object
	var tagcollector = [];
    var tagnamecheck = [];

    for (var a = 0; a < stepcollector.length ; a++){
    	var step = stepcollector[a];
    	// console.log('stepcollector key', step.key, step.session_by_user.length);

        for (var j = 0 ; j < step.session_by_user.length; j ++){
        	
        	// for each session/user, get messages
            for (var k = 0 ; k < step.session_by_user[j].messages.length; k++){

            	// get the messages from that step and their tags
            	if(step.session_by_user[j].messages[k].tags.length != 0){
            		// console.log('are there any tags', step.session_by_user[j].messages[k].tags)
	                for (var l = 0; l < step.session_by_user[j].messages[k].tags.length; l++){

	                	// console.log('stepcollector key', step.key);
	                    if(!(tagnamecheck.indexOf(step.key) != -1)){
	                        tagnamecheck.push(step.key);
	                        var tagMaker = step.session_by_user[j].messages[k].tags[l];
	                        tagcollector.push({key : step.key, tags : [ tagMaker ] });
	                        
	                    } else if (tagnamecheck.indexOf(step.key) != -1){
	                        for (var m in tagcollector){
	                            if (step.key == tagcollector[m].key){
	
	                                var tagMaker = step.session_by_user[j].messages[k].tags[l];
	                                tagcollector[m].tags.push(tagMaker);
	                            }
	                        }
	                    }
	                }
	            }    
            }
        }
    }

    // console.log('tagcollector', tagcollector)

			for (var i = 0; i < stepcollector.length; i++){
            	var step = stepcollector[i]
                for (var j = 0; j < tagcollector. length; j++){
                    if (step.key == tagcollector[j].key ){
                        var tags = tagcollector[j].tags;
                        tags.sort();

                        // de-dupe array, then post to tags_single
                        //  so we summarize and visible.
                        var tagDupe = [];
                        var tagCount = 0;
                        var curTag = null;

                        for (var k = 0; k < tags.length +1; k++){
                            if (tags[k] != curTag){     
                                if (tagCount > 0) {
                                    tagDupe.push({body: curTag.replace(/#/gi,''), count : tagCount});
                                }

                                curTag = tags[k];
                                tagCount = 1;
                            } else {
                                tagCount++;
                            }
                        }

                        tags = [];
                        for ( var key in tagDupe ){
                            tags.push({body: tagDupe[key].body, count : tagDupe[key].count, visible: true});
                        }
                        // push single tags to each flow step
                        step.tags_single = tags;
                    }
                }
            }

	return stepcollector;
}

function tagcollector(array){
        // arrange the tags for theme summarizing
        // console.log('tagcollector function', array);
        var tags = [];
        // array is an array of steps
        for (var i = 0; i < array.length -1 ; i++){
            for(var j = 0; j < array[i].tags_single.length -1; j++){
                tags.push(array[i].tags_single[j])
            }
        }

     return tags;
}

